---
title: 2024面向对象的软件工程
category: 笔记
tag: 总结
comment: true
abbrlink: 52072
date: 2023-09-08 17:54:00
---

# 面向对象方法学

## 面向对象方法概述

- 面向对象（Object Oriented，OO）方法学的出发点和基本原则是尽可能模拟人类习惯的思维方式，使开发软件的方法与过程尽可能接近人类解决问题的方法与过程。
- OO = Objects + Classes + Inheritance + Communication with messages

:::primary
面向对象方法学的发展
:::

- 初期阶段（20世纪60年代开始）
- 发展阶段（20世纪80年代中期到90年代）
- 成熟阶段（20世纪90年代以后）

:::primary
面向对象方法学的优点与不足
:::

- 面向对象方法学的主要优点
    - 与人类习惯的思维方式一致
    - 软件稳定性好
    - 可重用性好
    - 较易开发大型软件产品
    - 可维护性好，易于测试

- 面向对象方法学的不足之处
    - 相对面向过程而言比较麻烦，需要写更多的代码
    - 占用空间比较多，程序效率比较低，如多态等特性会降低性能
    - 创建对象实例的过程往往是非常耗时的工作，因为一些认为【万事皆对象】的语言，对于一些简单类型的操作性能比较低
    - 对系统动态特征表述不充分（主要是整体动态特征），且反映系统整体功能特征的能力比较差。
    - 面向对象方法学4大特性（抽象、封装、继承和多态）在一定程度上避免了不合理的操作，并能有效地阻止错误的扩散，减轻了维护工作量，但是也加大了测试的难度，给软件测试带来不便。

## 面向对象的软件工程

- OOA (Objected Oriented Analysis) 面向对象的分析

- OOD (Objected Oriented Design) 面向对象的设计

- OOP (Objected Oriented Programming) 面向对象的编程

- OOT (Objected Oriented Test) 面向对象的测试

- OOSM (Objected Oriented Software Maintenance) 面向对象的软件维护

- OOA -> OOD -> OOP -> OOT -> OOSM
:::primary
面向对象的基本概念
:::
- 对象
    - 是一组静态特征和动态特征的封装体
- 类
    - 具有抽象，无值的特征
- 消息
- 封装

:::primary
对象、类及类之间关系的分析
:::

- 类与对象的关系
    - 模板与实例的关系
- 类与类之间的关系
    - 继承 (Inheritance)
    - 多态性 (polymorphism)
    - 关联 (Association)
    - 依赖 (dependency)
    - 实现 (Realization)
    - 聚集 (Aggregation) 与 组合(Composition)
        - 关联与聚合的区别如下
            - 关联和聚合在代码层面是一致的，只能从语义级别来区分。
            - 关联的两个对象之间一般是平等的
            - 聚集则一般是不平等的

        - 强弱关系：组合 > 聚集 > 关联 > 依赖

:::primary
典型的面向对象开发方法
:::
- Booch方法
- Coad/Yourdon方法 (简称 Coad 方法或 OOAD 方法)
    - OOA 面向对象的分析
    - OOD 面向对象的分析
- OMT/Rumbaugh 方法
    - OMT (Object Modeling Technique) 对象模型化技术
- OOSE方法/Jacobson方法
    - OOSE (Object Oriented Software Engineering) 面向对象软件工程
    - 需求模型
    - 分析模型
    - 设计模型
    - 实现模型
    - 测试模型
- Wirfs - Brock 方法
    - Wirfs - Brock 方法主要包括以下步骤
        1. 评估客户规约
        2. 使用语法分析从规约中抽取候选类
        3. 组合类以试图标识超类
        4. 为每个类定义责任
        5. 为每个类赋予责任
        6. 标识类之间的关系
        7. 定义类之间基于责任的协作
        8. 构造类的层次表示以显示继承关系
        9. 构造系统的协作图
- 上述5种方法的比较
    - Booch 方法并不是一个开发过程，只是在开发面向对象系统时应遵循的一些技术和原则。
    - OMT方法覆盖了应用开发的全过程，是一种比较成熟的方法，用几种不同的观念来适应不同的建模场合，他在许多重要观念上受到关系数据库设计的影响，适用于数据数据密集型的信息系统的开发，是一种比较完善和有效的分析与设计方法。
    - 在 OOAD 方法中，OOA 把系统横向划分为5个层次，OOD 把系统纵向划分为4个部分，从而形成了一个清晰的系统模型。OOAD适用于小型系统的开发。
    - OOSE 能够较好地描述系统的需求，是一种实用的面向对象的系统开发方法，适用于商务处理方面的应用开发。
    - Wirfs-Brock 方法不明确区分分析和设计任务，从评估客户规格说明到设计完成，是一个连续的过程。
- 统一建模语言UML (Unified Modeling Language)
    - 该方法力图实现OMT方法和Booch方法的统一。

## 统一建模语言 UML
:::primary
概述
:::
- UML是一种编制软件蓝图的标准化语言，需要强调的是，UML是一种建模语言而不是方法，UML本身是独立于过程的。
- UML建立在当今国际上最具有代表性的3种面向对象方法（Booch 方法，OMT 方法，OOSE 方法）的基础之上，由OMG (Object Management Group)国际对象管理组织 于 1997年11月批准为标准建模语言，支持面向对象的技术和方法，能够准确方便地表达面向对象的概念，体现面向对象的分析和设计风格。
- UML的建模过程包括分析和设计两个建模阶段
    - 分析阶段主要通过[用例图、类图、活动图、类分析图、顺序图].{rainbow}等表示分析结果；
    - 设计阶段主要通过[类设计图、通信图、状态图、构件图、部署图]{.rainbow}等表示设计结果;

:::primary
UML 的发展
:::

- 统一建模语言UML起源于两位杰出的面向对象方法大师Booch 和 Rumbaugh 及 著名的软件工具制造企业 Rational Software。他们于1994年10月加盟了该公司，于1995年10月将两种方法合并，推出统一方法（Unified Method）。同年......

:::primary
UML 的定义及主要内容
:::
- UML的语义
    - UML的语义在一个四层抽象级别的建模框架中定义。
    - 元元模型 (Meta-Meta Model) 层
    - 元模型 (Meta Model) 层
    - 模型层 (Model) 层
    - 用户模型 (User Model) 层
- UML的表示方法
    - 视图 (View)
    - 图 (Diagram)
    - 模型元素 (Model Element)
    - 公共机制 (Common Mechanism)
- UML 的构成 (3类主要元素)
    - [基本构造块]{.label .primary} (Basic Building Block)
        - [事物]{.label .info} (Thing)
            - [结构事物]{.label} (Structural Thing)
                - 类 (Class)
                - 接口 (Interface)
                - 协作 (Collaboration)
                - 用例 (Use Case)
                - 主动类 (Active Class)
                - 构件 (Component)
                - 结点 (Node)

            - [行为事物]{.label} (Behavioral Thing)
                - 交互 (Interaction)
                - 状态机 (State Machine)

            - [分组事物]{.label} (Grouping Thing)
                - 包 (package)
            
            - [注释事物]{.label} (Annotation Thing)
                - 注解 (Note)

        - [关系]{.label .info} (Relationship)
        - [图]{.label .info} (Diagram)
    - [规则]{.label .primary} (Rule)
        - 命名 (Name)
        - 范围 (Scope)
        - 可见性 (Visibility)
        - 完整性 (Integrity)
        - 执行 (Execution)
    - [公共机制]{.label .primary} (Common Mechanism)
        - 规范说明 (Specification)
        - 修饰 (Adornment)
        - 通用划分 (Common Division)
        - 扩展机制 (Extensibility Mechanism)
            - 版型 (Stereotype)
            - 标记值 (Tagged Value)
            - 约束 (Constraint)
- UML的构成图
- ![UML的构成图](/img/software/UML的构成图.png)

:::primary
UML 的特点和用途
:::
- 特点
    - 统一的标准
    - 面向对象
    - 可视化，表示能力强大
    - 独立于过程
    - 易于掌握应用
- UML 是一个通用的标准语言，在系统开发的各个阶段的都可使用UML,其应用覆盖了从需求分析到软件测试的各阶段。
    - 需求分析阶段
    - 系统分析阶段
    - 系统设计阶段
    - 编码阶段
    - 测试阶段

:::primary
UML 的模型视图简介
:::
- 静态图
    - 类图
    - 对象图
    - 用例图
    - 构件图
    - 部署图
    - 包图
- 动态图
    - 状态图
    - 顺序图
    - 通信图
    - 活动图
    - 计时图
    - 交互概览图
- 视图
    - 用例视图 (Use Case View)
    - 逻辑视图 (Logical View)
    - 进程视图 (Process View)
    - 实现视图 (Realization View)
    - 部署视图 (Deployment View)

:::primary
UML 常用工具
:::
- Rational Rose
- Star UML
- Visio Professional

:::primary
Rational Rose
:::

- 对面向对象模型的支持
- 对螺旋上升式开发过程的支持
- 对双向工程的支持
- 对团队开发的支持
    - 个人工作间 (Workspace)
    - 配置管理CM (Configuration Management)
    - 虚拟路径地图 (Virtual Path Maps)
    - 提供与ClearCase (Rational 公司的软件版本控制产品)

    - 在对项目团队开发的管理方面，Rational Rose 支持的每次迭代包括6个阶段。
        - 计划
        - 蔓延
        - 延伸
        - 整合
        - 评估
        - 发布
- 对工具的支持

## 统一软件开发过程 RUP 概述

- RUP (Rational Unified Process) 是一个面向对象软件工程的通用业务流程。

:::primary
RUP 的历史
:::

:::primary
RUP 的特色
:::

- 迭代和增量方法

- 以软件体系结构为中心

:::primary
RUP 软件开发的生存周期
:::

- 动态结构
    - 初始阶段
    - 细化阶段
    - 构造阶段
    - 交付阶段
- 静态结构
    - 业务建模 (Business Modeling)
    - 需求 (Requirements)
    - 分析和设计 (Analysis & Design)
    - 实现 (Realization)
    - 测试 (Test)
    - 部署 (Deployment)
    - 项目管理 (Project Management)
    - 配置与变更管理 (Configuration & Change Management)
    - 环境 (Environment)

:::primary
RUP 过程的建模
:::

- 初始阶段
- 细化阶段
- 构造阶段
- 交付阶段

## 本章小结

- 面向对象方法学尽可能模拟人类认识客观世界的思维方式来进行软件开发、使开发软件的方法与过程尽可能接近人类解决问题的方法与过程，能够开发出稳定性好、可重用性好、可维护性好的软件，并且较易开发大型软件产品，这些都是面向对象方法学的突出优点

- 面向对象软件工程是面向对象方法学在软件工程领域的全面应用，可应用在生存周期的各个阶段。本章还介绍5种典型的面向对象方法及其特点。

- 统一建模语言UML是在面向对象方法学大战后的集成和统一，被国际对象管理组织 OMG 接纳为标准建模方法和语言。最新的 UML2.0 版共包含 3 类主要元素、4 类事物和 13 种图形，并提供 5 种视图用于系统的建模指导，本章还介绍了支持 UML 的相关工具。

- 统一软件开发过程 RUP (Rational Unified Process) 是一个面向对象软件工程的通用业务流程，强调整个开发过程中的多次迭代，为在开发组织中分配任务和职责提供了一种规范的方法。RUP 软件开发生存周期是一个二维的软件开发模型，横轴代表时间，显示过程的生存周期，体现了过程的动态结构；纵轴给出 RUP 软件开发过程中的核心工作流，表示 RUP 软件开发过程的静态结构。 

# 面向对象的分析

## 面向对象的分析过程

- 面向对象分析就是抽取和整理用户需求并建立问题领域精确模型的过程。OOA 强调运用面向对象方法，对问题域和系统职责进行分析和理解，找出描述问题域及系统职责所需要的对象，定义对象的属性、服务及他们之间的关系，以便建立一个符合问题领域、满足用户需求的 OOA 模型。

- 面向对象分析过程，首要的是先建模，通常需要建立4种形式的模型：
    - 用类和对象表示的对象 (静态) 模型
    - 用用例和场景表示的用例 (功能) 模型
    - 由状态机和交互图表示的动态行为模型
    - 由构件图和部署图表示的物理实现模型

- 4 种模型之间的关系
    - 针对每个类建立的动态模型，描述类实例的生存周期或运行周期
    - 状态转换驱使行为发生，这些行为在数据流图中被映射成处理，在用例图中被映射成用例，他们同时与类图中的服务相对应。
    - 用例 (功能) 模型中的用例 (或处理) 对应于对象模型中的类所提供的服务。
    - 数据流图中数据存储及数据的源点/终点通常是对象模型中的对象
    - 数据流图中数据流往往是对象模型中对象的属性值，也可能是整个对象
    - 用例图中的参与者可能是对象模型中的对象
    - 用例 (功能) 模型中的用例 (或处理) 可能产生动态模型中的事件
    - 对象模型描述数据流图中的数据流、数据存储及数据源点/终点的结构
    - 物理实现模型中的构件通常对应对象模型中的类

## 建立用例模型

:::primary
需求分析与用例建模
:::

:::primary
确定系统范围和系统边界
:::

:::primary
确定参与者
:::
- 通常通过回答以下问题找到参与者
    - 谁使用系统的主要功能？
    - 谁需要系统的支持已完成其日常工作任务？
    - 谁负责维护、管理并保证系统的正常运行？
    - 系统需要和那些外部系统交互？
    - 系统需要处理那些设备？
    - 对系统产生的结果感兴趣的人或事物是那些？
:::primary
确定用例
:::

:::primary
确定用例之间的关系
:::
- 包含关系
- 扩展关系
- 泛化关系
- 使用关系

## 建立对象模型

- 5个层次对应着建立对象模型的5项活动：
    - 找出类和对象
    - 识别结构
    - 识别主题
    - 定义属性
    - 定义服务

面向对象分析大体上按照下列顺序进行:
:   寻找类和对象 -> 识别结构 -> 识别主题 -> 定义属性 -> 建立动态模型 -> 建立功能模型 -> 定义服务

:::primary
确定类和对象
:::

筛选过程主要依据下列标准来删除不正确或不必要的类和对象
:   冗余
:   无关
:   笼统
:   属性
:   操作
:   实现

:::primary
确定关联
:::

标识关联的启发式规则有
:   从需求描述中查找动词或动词短语，识别动作的主体和客体，从角色寻找关联；
:   准确地命名关联和角色；
:   尽量使用常用的修饰词标识名字空间和关键属性；
:   应删除派生关联，即可由其他关联导出的关联；
:   在一组关联被确定下来之前，先不必考虑实例之间的多重性
:   为适用于不同的关联，必要时要分解以前确定的类；
:   分析过程中，及时补上遗漏的关联

:::primary
确定属性
:::

:::primary
建立对象类图
:::


:::primary
划分主题
:::

:::primary
优化对象模型
:::

## 建立动态行为模型
:::primary
建立顺序图
:::

:::primary
建立通信图
:::

:::primary
建立状态图
:::

- 状态机及状态图的定义
- 状态
- 事件
    1. 入口事件
    2. 出口事件
    3. 动作事件
    4. 信号事件
    5. 调用事件
    6. 修改事件
    7. 时间事件
    8. 延迟事件
- 转换
    1. 外部转换
    2. 内部转换
    3. 完成转换：又称自转换
- 触发事件
- 监护条件
- 动作
- 状态图的建模步骤
    1. 找出适合用模型描述其行为的类
    2. 确定对象可能存在的状态
    3. 确定引起状态转换的事件
    4. 确定转换进行时对象执行的相应动作
    5. 对建模的结果进行相应的精化和细化
- 建立状态图
    1. 编写典型交互行为脚本
    2. 从脚本中提取出事物，确定触发每个事件的动作对象及接受事件的目标对象。
    3. 排列事件发生的次序，确定每个对象可能有的状态及状态间转换关系，并用状态图描绘出来。
    4. 比较各个对象的状态图，检查它们之间的一致性，确保事件之间的匹配。    

:::primary
建立活动图
:::

1. 活动图与流程图

2. 活动图与状态图

3. 活动图的组成及 UML 图形表示
    - 动作状态
    - 活动状态
    - 动作流
    - 分支与合并
    - 分叉与汇合
    - 分区
    - 对象流
4. 活动的分解

5. 活动图建模技术

    - 识别要对工作流描述的类或对象。
    - 确定工作流的初始状态和终止阶段，明确工作流的边界。
    - 对动作状态或活动状态建模。
    - 对动作流建模
    - 对对象流建模
    - 对建立的模型进行精化和细化

## 建立物理实现模型

:::primary
建立构件图
:::

1. 构件 (Component)
2. 构件的接口
3. 对构件和构件关系建模的用途
4. 构件图 (Component Diagram)
    - 源代码文件建模
    - 可执行文件和库建模
    - 表、文件和文档建模

:::primary
建立部署图
:::

1. 部署图的要素
    - 结点
    - 连接
2. 如何开发部署模型
    - 确定模型范围
    - 确定分布结构
    - 确定结点和他们的连接
    - 把构件分布到结点
    - 为不同构件之间的依赖建模
3. 几种部署图建模方法
    - 构建的分布建模
    - 嵌入式系统建模
    - 客户机/服务器建模

## 面向对象软件开发过程的案例分析

:::primary
系统需求
:::
1. 客户预约汽车
2. 客户得到汽车
3. 客户返还汽车

:::primary
系统用例模型
:::

1. 定义参与者
2. 用例图

:::primary
系统对象模型
:::

:::primary
系统动态行为模型
:::

1. 顺序图和通信图
    - 顺序图
    - 通信图
2. 状态图和活动图
    - 状态图
    - 活动图

:::primary
系统物理实现模型
:::

1. 构件图
2. 部署图

## 本章小结

- 面向对象的分析就是抽取和整理用户需求，并建立问题领域精确模型的过程。
- 分析工作主要包括3项内容：理解、表达和验证。与传统的面向数据流的结构化方法以功能为导向的分析，构建的是面向类的模型。一般地，可通过对象模型、用例 (功能) 模型、动态 (行为) 模型和物理实现模型来表达分析结果。
- 本章最后通过一个简化的汽车租赁系统的分析过程给出面向对象分析的应用案例。
- 本章以面向对象的概念为基础，介绍了以这4种模型为基础进行建模的基本方法和注意事项，为面向对象软件的分析过程提供指导。


# 面向对象的设计与实现

## 面向对象的设计准则和启发式规则

:::primary
面向对象设计准则
:::

1. 模块化
2. 抽象
3. 信息隐蔽
4. 弱耦合
    - 交互耦合
    - 继承耦合
5. 强内聚
    - 服务内聚
    - 类内聚
    - 一般 - 特殊内聚
6. 可重用
    - 尽量使用已有的类
    - 如果确实需要创建新类，则在设计这些新类的协议时，应该考虑将来的可重复使用性

:::primary
启发式规则
:::

1. 设计结果应该清晰易懂
    - 用词一致
    - 使用已有的的协议
    - 减少消息模式的数据
    - 避免模糊的定义
2. 一般 - 特殊结构的深度应适当
3. 设计简单的类
4. 使用简单的协议
5. 使用简单的服务
6. 把设计变动减至最小

## 系统设计

:::primary
问题域子系统设计
:::

1. 为复用设计与编程的类而增加结构
2. 按编程语言调整继承关系
3. 提高性能
4. 为编程方便增加底层成分，通过细化对象的分类来实现
5. 对复杂关联的转化并决定关联的实现方式
6. 调整与完善属性
7. 构造或优化算法，调整服务
8. 其他

:::primary
人机交互子系统设计
:::

1. 用户分类
2. 描述与系统交互的参与者的脚本
3. 设计详细的交互
4. 设计命令层
5. 设计人机交互类
6. 继续做原型

:::primary
任务管理子系统设计
:::

1. 确定任务的特征 (如事件驱动、时钟驱动等)
2. 定义协调者任务和关联的对象
3. 集成协调者和其他任务

:::primary
任务管理子系统设计
:::

1. 选择数据存储管理的模式
    - 文件管理系统
    - 关系数据库管理系统
    - 面向对象数据库管理系统
2. 设计数据管理子系统
    - [数据格式设计]{.label}
        - 文件管理系统
        - 关系数据库管理系统
        - 面向对象数据库管理系统
    - [服务设计]{.label}
        - 文件管理系统
        - 关系数据库管理系统
        - 面向对象数据库管理系统

## 服务、关联与聚合关系设计

:::primary
服务设计
:::

1. 确定类中应有的服务
    - 从对象模型中引入服务
    - 从动态模型中确定服务
    - 从用例模型中确定服务

2. 设计实现服务的方法
    - 选择数据结构
    - 定义内部类和内部操作
    - 设计实现服务的算法
    - 算法复杂度
    - 容易理解和实现
    - 易修改和易维护

:::primary
关联设计
:::

1. 单向关联与双向关联
2. 关联的命名
3. 角色
4. 关联类及其属性
5. 关联的约束
6. 关联的限定符
7. 关联的种类

:::primary
聚合关系设计
:::

1. 简化了对象的定义
2. 支持软件重用
3. 聚集和组合的区别如下：
    - 聚集关系称为 "has-a"关系,组合关系称为 "contains-a"关系
    - 聚集关系表示事物的整体/部分关系的较[弱]{.red}的情况，组合关系表示事物的整体/部分关系的较[强]{.red}的情况。

## 面向对象设计优化
1. 确定优先级
2. 提高效率的几项技术
    - 增加冗余关联以提高访问效率
    - 调整查询次序
    - 保留派生属性
3. 调整继承关系
    - 抽象与具体
    - 为提高继承程度而修改类定义
    - 利用委托实现行为共享

## 面向对象系统的实现

:::primary
面向对象程序设计语言的选择
:::

1. 面向对象程序设计语言的优点
2. 面向对象语言的技术特点
3. 选择面向对象语言的实际原因

:::primary
面向对象程序设计风格
:::

1. 提高可重用性
2. 提高可扩充性
3. 提高健壮性

## 本章小结
- 面向对象设计是面向对象分析内容的细化和扩展，目的是解决分析阶段所得到模型 “如何做” 的问题。面向对象设计把分析阶段得到的对目标系统的需求转变为符合成本和质量要求的、抽象的系统实现方案。 
- 面向对象方法学在概念和表示方法上的一致性，保证了在各开发活动之间的平滑过渡，从面向对象分析、面向对象设计，再到面向对象的实现，实际上就变成了一个逐渐扩充模型的过程。面向对象分析、设计和实现是一个多次反复迭代的过程。
- 本章首先介绍了面向对象设计应遵循的准则和启发式准则。大多数求解空间模型，在逻辑上由问题域、人机交互、任务管理和数据管理4大部分组成，本章按照系统分解的观点，介绍了这4个子系统的设计策略和方法。根据面向对象分析和设计过程的迭代特性，面向对象设计阶段需要对类中的服务、关联和聚合等关系进行细化，同时需要按照一定规则对设计进行优化。本章最后对面向对象实现所涉及的程序设计语言的选择和程序设计的风格问题进行了介绍。


# 软件开发工具 StarUML 及其应用 
## 软件开发工具 StarUML 概述
:::primary
StarUML 的安装及使用
:::
1. 运行 StarUML (tm) 的最低系统需求
2. StarUML 的安装步骤
3. StarUML 的使用

:::primary
StarUML 的主要功能
:::
## StarUML 环境下的 UML 图形建模
:::primary
StarUML 的用例图、类图和包图
:::

1. 用例图
2. 类图
3. 包图
:::primary
StarUML 的交互图和状态机图
:::

1. 顺序图和通信图
2. 状态图和活动图
:::primary
StarUML 的构件图与部署图
:::
1. 构件图
2. 部署图
:::primary
StarUML 的正向工程和逆向工程
:::
1. 代码生成
2. 逆向工程

## 一个简易教学管理系统的分析和设计
:::primary
系统需求描述及分析
:::
:::primary
系统问题领域分析
:::
1. 确定系统范围和系统边界
2. 定义参与者
3. 定义用例
4. 绘制用例图
5. 绘制主要交互图
:::primary
静态结构模型的建立
:::
:::primary
动态行为模型的建立
:::

1. 建立顺序图
2. 建立通讯图
3. 建立状态图
4. 建立活动图
:::primary
系统物理模型的建立
:::
:::primary
代码框架自动生成的过程
:::
## 本章小结
- StarUML 是一款开源的 UML 建模工具，基于UML1.4版本，提供11种不同类型的图，支持 UML2.0的表示法。另外，StarUML 的扩展机制还允许用户增加定制内容，使用灵活、方便。
- 本章介绍了 StarUML 环境下几种典型的 UML 图形建模的基本用法，并通过一个简易教学管理系统的分析和设计，展示了 StarUML 用于分析设计过程的辅助用法。

# 软件体系结构

## 软件体系结构概述

## 经典的软件体系结构风格
:::primary
管道-过滤器 (流程处理) 体系结构
:::
- 流程处理系统 (Procedure Processing System) 以程序算法和数据结构为中心，由称作过滤器的构件和称作管道的连接件组成的体系结构 (常常被称作管道-过滤器体系结构)。每一个处理过程中，先接收数据、进行处理 (过滤)，最后产生输出数据。
:::primary
分层体系结构
:::

:::primary
客户机/服务器体系结构
:::

1. 两层的客户机/服务器体系结构

2. 3层和多层体系结构

:::primary
浏览器/服务器体系结构 (B/S)
:::
## 现代的软件体系结构风格
:::primary
公共对象请求代理体系结构
:::

:::primary
基于层次消息总线的体系结构风格
:::

:::primary
异构结构风格
:::

1. 按功能不同构成的混合体系结构
2. 按结点组合方式的不同构成的混合体系结构

    - 随机式
    - 轮流式
    - 负载平分式
    - 多队列式

## 本章小结
- 面向对象技术的出现和广泛使用，在一定程度上解决了软件可复用性的问题，但同时对软件的可复用性提出了更高的要求，从程序代码的复用逐渐过渡到分析、设计的复用上来。软件体系结构就是希望为软件开发的工程化提供更高抽象层次的复用粒度。

- 软件体系结构可以看作是面向对象设计阶段中的总体设计，提供系统设计的总体架构。
- 本章分别介绍几种经典的和现代的软件体系结构的风格和模式，为面向对象设计的总体架构设计提供指导，同时希望在设计复用方面对现代软件工程开发过程提供一些帮助。

# 设计模式
## 设计模式概述
:::primary
设计模式的出现和发展
:::
:::primary
设计模式和软件体系结构的关系
:::
:::primary
设计模式的优点和分类
:::

## GRASP 设计模式及其应用
:::primary
GRASP 设计模式概念及其分类
:::

:::primary
几种典型的 GRASP 设计模式应用简介
:::
1. 信息专家 (Information Expert)
2. 创建者 (Creator)
3. 高内聚 (Hign Cohesion)
4. 低耦合 (Low Goupling)
5. 控制者 (Controller)
6. 多态 (Polymorphism)
7. 纯虚构 (Pure Fabrication)
8. 间接，也成为中介者 (Indirection)
9. 受保护变化 (Protected Variations)

## GoF 设计模式及其应用
1. 模式名称
2. 问题
3. 解决方案
4. 效果

- 设计模式的描述
- 设计模式的用途
- GoF给出的 "使用设计模式的循序渐进的方法"

:::primary
GoF 设计模式的组成及其分类
:::
1. 创建型模式 (Creational Pattern)：处理新对象的创建过程
    - 工厂方法 (Factory Method)
    - 抽象工厂 (Abstract Factory)
    - 生成器 (Builder)
    - 原型 (Prototype)
    - 单例 (Singleton)
2. 结构性模式 (Structural Pattern)：处理类和对象的组成
    - 适配器 (Adapter)
    - 桥接 (Bridge)
    - 组成 (Composite)
    - 装饰 (Decorator)
    - 外观 (Facade)
    - 享元 (FlyWeight)
    - 代理 (Proxy)

3. 行为型模式 (Behavioral Pattern)：详细说明对象或类之间如何交互及如何分配职责。
    - 责任链 (Chain of Responsibility)
    - 命令 (Command)
    - 解释器 (Interpreter)
    - 迭代器 (Iterator)
    - 中介者 (Mediator)
    - 备忘录 (Memento)
    - 观察者 (Observer)
    - 状态 (State)
    - 策略 (Strategy)
    - 模板方法 (Template Method)
    - 访问者 (Visitor)

## 本章小结
- 设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格及解决问题的思考方式。使用设计模式是为了重用已有的设计经验、框架、代码，以便让代码更容易被他人理解，保证代码可靠性。对设计模式的理解和掌握是程序员提高自身素质的一个很好的方面。
- GRASP 模式着重考虑设计类的原则及如何分配类的功能。
- GoF 模式着重考虑设计的实现、类的交互和软件质量。
- GRASP 可以说是 GoF 设计模式的基础，GoF模式是符合 GRASP 模式要求的面向对象设计模式。GoF 设计模式针对特定问题提出相应解决方法，是目前常用的设计模式之一。

- 本章主要介绍设计模式的基本概念和发展、GRASP 设计模式和GoF设计模式的概念及其分类，并给出典型的应用实例，目的是使读者掌握设计模式的基本理论及应用设计模式解决软件设计中的实际问题的方法。

# 软件工程新技术

## 软件复用技术
- 软件复用 (Software Reuse) 是指在软件开发过程中重复使用相同或相似软件元素的过程。通过软件复用，可以提高软件开发的效率和质量。

:::primary
软件复用概念及分类
:::

:::primary
软件复用的关键技术和复用粒度
:::
- 软件复用有3个基本问题
    1. 必须有可以复用的对象
    2. 所复用的对象必须是有用的
    3. 复用者需要知道如何去使用被服用的对象。

## 基于构件的软件工程技术

:::primary
中间件技术
:::

- 中间件是一个用应用程序接口定义的分布式软件管理框架，其有强大的通信能力和良好的可扩展性。

1. 中间件要解决的问题
    - 互连和互操作的问题
    - 核心要解决名字服务、安全控制、并发控制、可靠性保证、效率保证等
    - 特点
        1. 满足大量应用的需要
        2. 运行于多种硬件和操作系统平台
        3. 支持分布式计算
        4. 提供跨网络、硬件和操作系统平台的透明性
        5. 支持标准的协议和接口
2. 中间件的分类
    - 根据中间件具有的功能和所提供的服务分类：
        1. 面向对象中间件
        2. 面向消息中间件
        3. 容错中间件
        4. 反射中间件
    - 基于 IDC 分类
        1. 终端仿真/屏幕转换
        2. 数据访问中间件
        3. 远程过程调用中间件
        4. 消息中间件
        5. 交易中间件
        6. 基于对象请求代理 (Object Request Broker ,ORB) 中间件
3. 中间件的发展及认识度

:::primary
构件与构件化
:::

- 构件技术的基本思想在于：创建和利用可复用的软件构件来解决软件开发的问题。

:::primary
构件模型及描述语言
:::

1. 构建模型
    - 构件实现模型的基本思想:
        - 采用将构件的接口和实现相分离的原则；
        - 采用黑盒重用的方式，外界仅可以通过构件的接口来访问构件的功能；
        - 在实现方法上都使用接口描述语言 (Interface Description Language , IDL) 进行构件接口定义，利用相应的中间件作为支撑该构件模型的运行时环境，从而达到由不同的编程语言所实现、运行在不同的操作系统环境中及不同主机上的构件都能相互交互的目的。
2. 构件描述语言

:::primary
构件的检索与组装
:::
1. 构件的检索
    - 枚举分类
    - 刻面分类
    - 属性值分类
    - 正文检索
    - 关键词分类
    
2. 构件组装技术
3. 构件组装技术及方法的分类
4. 构件组装的实现方法

:::primary
基于构件的软件工程方法
:::

- 软件团队针对系统需求的构件,采用如下问题列表的方式确认本系统中需要的构件的获取方式：
    1. 现有的商业成品构件 (Commercial Off-The-Shelf, COTS) 是否能够实现该需求？
    2. 内部开发的可复用构件是否能够实现该需求？
    3. 可用构件的接口与待构造系统的体系结构是否相容？

:::primary
SOA 与 SaaS
:::

- SOA (Service-Oriented Architecture,面向服务架构)
- SaaS (Software-as-a-Service,软件即服务)
## 软件过程与标准化
:::primary
软件过程及其改进
:::

1. 对比目前的状态和期望达到的状态，找出存在的差距。
2. 确定要改变那些差距，需要改变到什么程度。
3. 制定相应的具体实施计划，其中的 "具体" 包括
    - 要有明确的、可以检验的目标；
    - 要定出检验成功与否的标准；
    - 要有具体的实施办法；
    - 指定具体执行计划的人，明确具体的职责和任务；
    - 明确执行计划的主要领导或协调者，以负责解决在计划执行中出现的问题
    - 要列出 "实施计划" 所应用的新技术与新工具及如何获得这些新技术与新工具。
:::primary
ISO 9000 标准
:::

:::primary
软件能力成熟度模型 (CMM)
:::

- CMM (Capability Maturity Model)卡内基梅隆大学软件工程研究院SEI受美国国防部委托制定的软件过程的改良、评估模型，也称为 SEI SW-CMM (Software Engineering Institute Software-Capability Maturity Model).
1. CMM 的内容

    - 初始级 (Initial)
    - 可重复级 (Repeatable)
    - 已定义级 (Defined)
    - 已管理级 (Managed)
    - 优化级 (Optimizing)
2. 关键过程域 (Key Process Area,KPA)
3. CMM 实施中应注意的问题
:::primary
PSP、TSP 和 CMMI
:::
1. 个体软件过程 (Personal Software Process , PSP)
2. 小组软件开发过程 (Team Software Process , TSP)
3. 能力成熟度继承模型 (Capability Maturity Model Integration , CMMI)
    - SW-CMM (Software CMM) 软件CMM
    - SE-CMM (System Engineering CMM) 系统工程CMM
    - SA-CMM (Software Acquisition CMM) 软件采购 CMM
    - IPT-CMM (Integrated Product Team CMM) 集成产品群组 CMM
    - P-CMM (People CMM) 人力资源能力成熟度模型


## 敏捷软件开发过程
:::primary
敏捷及敏捷过程的相关概念
:::
1. "敏捷过程" 在软件业中的提出
    - 可工作软件胜过面面俱到的文档
    - 客户合作胜过合同谈判
    - 响应变化胜过遵循计划

2. 敏捷的概念
3. 敏捷宣言所遵循的12条原则
    1. 人们最优先要做的是通过尽早地、持续地交付有价值的软件来使客户满意
    2. 即使到了开发的后期，也欢迎改变需求。敏捷过程利用变化来为客户创造竞争优势
    3. 经常性的交付可以工作的软件，交付的间隔可以从几个星期到几个月，交付的时间间隔越短越好。
    4. 在整个项目开发期间，业务人员和开发人员必须天天都在一起工作。
    5. 围绕被激励起来的个体来构建项目。给它们提供所需的环境和支持，并且信任它们能够完成工作。
    6. 在团队内部，最具有效果并且富有效率的传递信息的方法就是面对面的交谈
    7. 工作的软件是首要的进度度量标准
    8. 敏捷过程提倡可持续的开发进度。责任人、开发者和用户应保持一个长期恒定的开发速度。
    9. 不断关注优秀的技能和好的设计会增强敏捷能力
    10. 简单 - [使未完成的工作最大化的艺术]{.rainbow} - 是根本的
    11. 最好的架构、需求和设计出自于自组织的团队
    12. 每隔一定时间，团队会在如何才能更有效的工作方面进行反省，然后相应地对自己的行为进行调整。
4. 敏捷软件过程的特性
    1. 轻载软件过程
    2. 基于时间
    3. 够用就好
    4. 并行
    5. 基于构建的软件工程
    
5. 敏捷软件过程模型 = 功能模型 + 合作模型 + 资源模型 + 产品模型

:::primary
典型的敏捷过程模型
:::
1. 极限编程 (eXtreme Programming , XP)
2. Scrum 方法
    - 待定项 (Backlog)
    - 冲刺 (Sprint)
    - 例会
    - 演示
3. 特征驱动开发 (Feature Driven Development , FDD)
    - FDD 的核心
        - 领域对象建模
        - 按照特征开发
        - 类 (代码) 拥有权
        - 特征小组
        - 审查
        - 定期构造
        - 配置管理
        - 可视性进度报告
    - FDD 方法包括5个过程组成
        - 开发整体模型
        - 构建特征列表
        - 依据特征规划
        - 依据特征设计
        - 依据特征构建
## Web 软件工程
:::primary
Web 软件工程概述
:::
1. 基于 Web 的系统和应用的属性和特点
    - 网络密集型 (Network Intensive)
    - 访问并发性 (Concurrency)
    - 工作负荷的跳跃性 (Unpredictable load)
    - 性能 (Performance)
    - 安全性 (Security)
    - 可用性 (Availability)
    - 数据驱动 (Data driven)
    - 内容敏感性 (Content Sensitive)
    - 持续演化 (Continuous Evolution)
    - 即时性 (Immediacy)
    - 美观性 (Aesthetics)
2. Web 工程过程
    - 计划阶段
    - 建模阶段
    - 构建阶段
    - 部署阶段
:::primary
Web 软件的需求分析
:::  
1. 内容模型
2. 交互模型
3. 功能模型
4. 配置模型
5. 导航模型
:::primary
Web 软件的设计
:::
1. WebApp 界面设计
2. 美学设计
3. 内容设计
4. 体系结构设计
    - 线性结构
    - 网络结构
    - 层次结构
5. 导航设计
    - 单独的导航链接
    - 水平导航条
    - 垂直导航列
    - 标签
    - 网站地图
6. 构件级设计
:::primary
Web 软件的测试
:::
1. 内容
2. 功能
3. 结构
4. 易用性
5. 导航性
6. 性能
7. 兼容性
8. 互操作性
9. 安全性

## 软件产品线技术
:::primary
软件产品线基本概念
:::

- 软件产品线的3大基本活动

- 软件产品线的特点
:::primary
软件产品线方法
:::
:::primary
北大青鸟工程
:::
- 青鸟工程简介

- 青鸟软件生产线系统

## 本章小结
- 随着软、硬件技术、网络的发展及计算理念的变化，软件工程领域也出现了很多新的技术。本章主要介绍继面向对象技术之后软件工程领域研究使用的新技术，包括软件复用技术、基于构建的软件工程技术（中间件和构件技术）、软件能力成熟度模型、敏捷软件工程、Web软件工程及软件产品线技术。 
- 软件复用技术是其他软件工程技术的核心和基础。基于构建的软件工程技术需要软件体系结构的支持。软件能力成熟度模型则是从软件过程改进的角度为个人、团队和整个软件开发组织提供参考。敏捷软件过程改变了传统的软件开发过程中先设计后实现的思想，敏捷更强调快速灵活反应，主动迎接和适应变化。敏捷开发能够适应中小型快速软件开发的需求，代表了21世纪互联网时代软件开发模式的一种先进理念和价值观。随着网络应用逐渐成为人们生活中不可或缺的组成部分，以 Web 系统和应用为主体的 Web 软件工程 (简称 Web 工程) 成为软件工程中一个渐渐分离的独立分支。Web 工程借用了软件工程的许多基本概念和原理，以相同的技术和管理活动完成具有 Web 应用特色的软件生存周期。软件产品线方法是软件工程领域中软件体系结构和软件重用技术发展的结果，产品线方法可以看作是软件复用发展的一个更高阶段，目前关于软件产品线的研究更多还在实验阶段。